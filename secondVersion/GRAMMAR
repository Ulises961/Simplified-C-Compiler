program -> typeSpec varDeclInit; | stmt | program program ***OK
varDeclInit -> varDeclId | varDeclId : simpleExp ***OK
varDeclId -> ID | ID[INT] ***OK (SECOND RULE MISSING)
typeSpec -> int | bool ***OK

stmt -> exp; ***SUBSTITUTED WITH simpleExp
        | ; ***???
        | if (simpleExp) compoundStmt ***OK
        | if (simpleExp) compundStmt else compundStmt  ***OK
        | while simpleExp do compoundStmt ***OK
        | break; ***OK
        | return; ***OK
        | return exp ; ***OK

compoundStmt -> {localDecls stmt} ***OK

localDecls -> localDecls scopedVarDecl | scopedVarDecl ***TODO
scopedVarDecl -> typeSpec varDeclInit; ***TODO

exp -> program | simpleExp ***SUBSTITUTED INTO stmt

simpleExp -> simpleExp or simpleExp | andExp ***OK

andExp -> andExp and unaryRelExp | unaryRelExp ***OK

unaryRelExp -> not unaryRelExp | unaryExp ***OK

relExp -> sumExp relOp sumExp | sumExp ***OK

relOp -> <= | < | >| >= | == | != ***OK

sumExp ->  sumExp sumOp mulExp | mulExp **OK
sumOp -> + | - **OK

mulExp -> mulExp mulOp unaryExp | unaryExp ***OK
mulOp -> * | / 

unaryExp -> - unaryExp | NUM | FALSE | TRUE | variable | (simpleExp)

variable -> ID


bool x : true;
bool y : false;
if (x or y) { x = false;}
return;
