program -> typeSpec varDeclInit; | stmt | program program ***OK
varDeclInit -> varDeclId | varDeclId : simpleExp ***OK
varDeclId -> ID | ID[INT] ***OK (SECOND RULE MISSING)
typeSpec -> int | bool ***OK

stmt -> exp; ***SUBSTITUTED WITH simpleExp
        | ; ***???
        | if (simpleExp) compoundStmt ***OK
        | if (simpleExp) compundStmt else compundStmt  ***OK
        | while simpleExp do compoundStmt ***OK
        | break; ***OK
        | return; ***OK
        | return exp ; ***OK

compoundStmt -> {localDecls stmt} ***OK

localDecls -> localDecls scopedVarDecl | scopedVarDecl ***TODO
scopedVarDecl -> typeSpec varDeclInit; ***TODO

exp -> program | simpleExp ***SUBSTITUTED INTO stmt

simpleExp -> simpleExp or simpleExp | andExp | true | false 

andExp -> andExp and unaryRelExp | unaryRelExp 

unaryRelExp -> not unaryRelExp | sumExp relOp sumExp | unaryExp
relOp -> <= | < | >| >= | == | != 

sumExp ->  sumExp sumOp mulExp | mulExp
sumOp -> + | -

mulExp -> mulExp mulOp unaryExp | unaryExp
mulOp -> * | / 

unaryExp -> - unaryExp | NUM | (sumExp) | variable

variable -> ID


bool x : true;
bool y : false;
if (x or y) { x = false;}
return;
