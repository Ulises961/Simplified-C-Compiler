program -> program stmt | program | â‚¬ ***OK (modified otherwise conflicts)

stmt -> exp; ***SUBSTITUTED WITH simpleExp
        | ; ***??? MUST DECLARE TYPE??
        | if (simpleExp) compoundStmt ***OK (how to implmenent goto??)
        | if (simpleExp) compundStmt else compundStmt  ***OK (how to implmenent goto??)
        | while simpleExp do compoundStmt ***OK (how to implmenent goto??)
        | break; ***OK
        | return; ***OK
        | return exp ; ***OK

varDeclInit -> typeSpec varDeclId : simpleExp | varDeclId : simpleExp ***OK (slightly modified)
varDeclId -> ID | ID[INT] ***OK (SECOND RULE MISSING)
typeSpec -> int | bool ***OK

compoundStmt -> {localDecls stmt} ***OK

localDecls -> localDecls scopedVarDecl | scopedVarDecl ***TODO
scopedVarDecl -> typeSpec varDeclInit; ***TODO

exp -> program | simpleExp ***SUBSTITUTED INTO stmt

simpleExp -> simpleExp or simpleExp | andExp ***OK

andExp -> andExp and unaryRelExp | unaryRelExp ***OK

unaryRelExp -> not unaryRelExp | unaryExp ***OK

relExp -> sumExp relOp sumExp | sumExp ***OK

relOp -> <= | < | >| >= | == | != ***OK

sumExp ->  sumExp sumOp mulExp | mulExp **OK
sumOp -> + | - **OK

mulExp -> mulExp mulOp unaryExp | unaryExp ***OK
mulOp -> * | /  ***OK

unaryExp -> - unaryExp | NUM | FALSE | TRUE | variable | (simpleExp) ***OK
 
variable -> ID ***OK


bool x : true;
bool y : false;
if (x or y) { x = false;}
return;
