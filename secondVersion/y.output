Terminals unused in grammar

    UMINUS


Rules useless in parser due to conflicts

    9 varDeclId: ID

   24 exp: program


State 0 conflicts: 11 shift/reduce, 12 reduce/reduce
State 9 conflicts: 12 shift/reduce, 12 reduce/reduce
State 12 conflicts: 12 shift/reduce, 24 reduce/reduce
State 20 conflicts: 1 shift/reduce
State 21 conflicts: 1 reduce/reduce
State 31 conflicts: 11 shift/reduce, 26 reduce/reduce
State 32 conflicts: 1 shift/reduce
State 35 conflicts: 11 shift/reduce, 42 reduce/reduce
State 36 conflicts: 1 reduce/reduce
State 62 conflicts: 1 shift/reduce
State 71 conflicts: 11 shift/reduce, 12 reduce/reduce
State 77 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: typeSpec varDeclId ':' simpleExp ';' '\n'
    2        | stmt
    3        | program program
    4        | boolExp '\n'
    5        | sumExp '\n'
    6        | mulExp '\n'

    7 varDeclInit: %empty

    8 varDeclId: ID
    9          | ID

   10 typeSpec: INT
   11         | BOOL

   12 stmt: exp
   13     | %empty
   14     | IF '(' simpleExp ')' compoundStmt
   15     | IF '(' simpleExp ')' compoundStmt ELSE compoundStmt
   16     | WHILE simpleExp DO compoundStmt
   17     | BREAK ';'
   18     | RETURN ';'
   19     | RETURN exp ';'

   20 compoundStmt: '{' localDecls stmt '}'

   21 localDecls: localDecls scopedVarDecl
   22           | scopedVarDecl

   23 scopedVarDecl: typeSpec varDeclInit

   24 exp: program
   25    | simpleExp

   26 simpleExp: %empty
   27          | boolExp
   28          | unaryExp

   29 boolExp: boolExp OR boolExp
   30        | boolExp AND unaryRelExp
   31        | unaryRelExp

   32 unaryRelExp: NOT unaryRelExp
   33            | sumExp relOp sumExp
   34            | TRUE
   35            | FALSE

   36 relOp: GR
   37      | GREQ
   38      | SM
   39      | SMEQ
   40      | EQ
   41      | NEQ

   42 sumExp: sumExp sumOp mulExp
   43       | mulExp

   44 sumOp: '+'
   45      | '-'

   46 mulExp: mulExp mulOp unaryExp
   47       | unaryExp

   48 mulOp: '*'
   49      | '/'

   50 unaryExp: '-' NUM
   51         | NUM


Terminals, with rules where they appear

    $end (0) 0
    '\n' (10) 1 4 5 6
    '(' (40) 14 15
    ')' (41) 14 15
    '*' (42) 48
    '+' (43) 44
    '-' (45) 45 50
    '/' (47) 49
    ':' (58) 1
    ';' (59) 1 17 18 19
    '{' (123) 20
    '}' (125) 20
    error (256)
    NUM <integer> (258) 50 51
    BOOL <integer> (259) 11
    ID <lexeme> (260) 8 9
    BREAK (261) 17
    AND (262) 30
    OR (263) 29
    NOT (264) 32
    IF (265) 14 15
    ELSE (266) 15
    WHILE (267) 16
    DO (268) 16
    EQ (269) 40
    NEQ (270) 41
    GREQ (271) 37
    GR (272) 36
    SM (273) 38
    SMEQ (274) 39
    TRUE <boolean> (275) 34
    FALSE <boolean> (276) 35
    RETURN (277) 18 19
    INT <integer> (278) 10
    UMINUS (279)


Nonterminals, with rules where they appear

    $accept (36)
        on left: 0
    program <symbol> (37)
        on left: 1 2 3 4 5 6
        on right: 0 3 24
    varDeclInit (38)
        on left: 7
        on right: 23
    varDeclId <lexeme> (39)
        on left: 8 9
        on right: 1
    typeSpec <lexeme> (40)
        on left: 10 11
        on right: 1 23
    stmt (41)
        on left: 12 13 14 15 16 17 18 19
        on right: 2 20
    compoundStmt (42)
        on left: 20
        on right: 14 15 16
    localDecls (43)
        on left: 21 22
        on right: 20 21
    scopedVarDecl (44)
        on left: 23
        on right: 21 22
    exp (45)
        on left: 24 25
        on right: 12 19
    simpleExp <integer> (46)
        on left: 26 27 28
        on right: 1 14 15 16 25
    boolExp <boolean> (47)
        on left: 29 30 31
        on right: 4 27 29 30
    unaryRelExp <boolean> (48)
        on left: 32 33 34 35
        on right: 30 31 32
    relOp <integer> (49)
        on left: 36 37 38 39 40 41
        on right: 33
    sumExp <integer> (50)
        on left: 42 43
        on right: 5 33 42
    sumOp <integer> (51)
        on left: 44 45
        on right: 42
    mulExp <integer> (52)
        on left: 46 47
        on right: 6 42 43 46
    mulOp <integer> (53)
        on left: 48 49
        on right: 46
    unaryExp <integer> (54)
        on left: 50 51
        on right: 28 46 47


State 0

    0 $accept: . program $end

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end      reduce using rule 13 (stmt)
    $end      [reduce using rule 26 (simpleExp)]
    NUM       [reduce using rule 13 (stmt)]
    NUM       [reduce using rule 26 (simpleExp)]
    BOOL      [reduce using rule 13 (stmt)]
    BOOL      [reduce using rule 26 (simpleExp)]
    BREAK     [reduce using rule 13 (stmt)]
    BREAK     [reduce using rule 26 (simpleExp)]
    NOT       [reduce using rule 13 (stmt)]
    NOT       [reduce using rule 26 (simpleExp)]
    IF        [reduce using rule 13 (stmt)]
    IF        [reduce using rule 26 (simpleExp)]
    WHILE     [reduce using rule 13 (stmt)]
    WHILE     [reduce using rule 26 (simpleExp)]
    TRUE      [reduce using rule 13 (stmt)]
    TRUE      [reduce using rule 26 (simpleExp)]
    FALSE     [reduce using rule 13 (stmt)]
    FALSE     [reduce using rule 26 (simpleExp)]
    RETURN    [reduce using rule 13 (stmt)]
    RETURN    [reduce using rule 26 (simpleExp)]
    INT       [reduce using rule 13 (stmt)]
    INT       [reduce using rule 26 (simpleExp)]
    '-'       [reduce using rule 13 (stmt)]
    '-'       [reduce using rule 26 (simpleExp)]
    $default  reduce using rule 13 (stmt)

    program      go to state 12
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 1

   51 unaryExp: NUM .

    $default  reduce using rule 51 (unaryExp)


State 2

   11 typeSpec: BOOL .

    $default  reduce using rule 11 (typeSpec)


State 3

   17 stmt: BREAK . ';'

    ';'  shift, and go to state 22


State 4

   32 unaryRelExp: NOT . unaryRelExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    unaryRelExp  go to state 23
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 5

   14 stmt: IF . '(' simpleExp ')' compoundStmt
   15     | IF . '(' simpleExp ')' compoundStmt ELSE compoundStmt

    '('  shift, and go to state 27


State 6

   16 stmt: WHILE . simpleExp DO compoundStmt

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    $default  reduce using rule 26 (simpleExp)

    simpleExp    go to state 28
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 7

   34 unaryRelExp: TRUE .

    $default  reduce using rule 34 (unaryRelExp)


State 8

   35 unaryRelExp: FALSE .

    $default  reduce using rule 35 (unaryRelExp)


State 9

   18 stmt: RETURN . ';'
   19     | RETURN . exp ';'

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11
    ';'     shift, and go to state 30

    NUM     [reduce using rule 13 (stmt)]
    NUM     [reduce using rule 26 (simpleExp)]
    BOOL    [reduce using rule 13 (stmt)]
    BOOL    [reduce using rule 26 (simpleExp)]
    BREAK   [reduce using rule 13 (stmt)]
    BREAK   [reduce using rule 26 (simpleExp)]
    NOT     [reduce using rule 13 (stmt)]
    NOT     [reduce using rule 26 (simpleExp)]
    IF      [reduce using rule 13 (stmt)]
    IF      [reduce using rule 26 (simpleExp)]
    WHILE   [reduce using rule 13 (stmt)]
    WHILE   [reduce using rule 26 (simpleExp)]
    TRUE    [reduce using rule 13 (stmt)]
    TRUE    [reduce using rule 26 (simpleExp)]
    FALSE   [reduce using rule 13 (stmt)]
    FALSE   [reduce using rule 26 (simpleExp)]
    RETURN  [reduce using rule 13 (stmt)]
    RETURN  [reduce using rule 26 (simpleExp)]
    INT     [reduce using rule 13 (stmt)]
    INT     [reduce using rule 26 (simpleExp)]
    '-'     [reduce using rule 13 (stmt)]
    '-'     [reduce using rule 26 (simpleExp)]
    ';'     [reduce using rule 13 (stmt)]
    ';'     [reduce using rule 26 (simpleExp)]

    program      go to state 31
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 32
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 10

   10 typeSpec: INT .

    $default  reduce using rule 10 (typeSpec)


State 11

   50 unaryExp: '-' . NUM

    NUM  shift, and go to state 33


State 12

    0 $accept: program . $end
    3 program: program . program
   24 exp: program .

    $end    shift, and go to state 34
    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end    [reduce using rule 13 (stmt)]
    $end    [reduce using rule 24 (exp)]
    $end    [reduce using rule 26 (simpleExp)]
    NUM     [reduce using rule 13 (stmt)]
    NUM     [reduce using rule 24 (exp)]
    NUM     [reduce using rule 26 (simpleExp)]
    BOOL    [reduce using rule 13 (stmt)]
    BOOL    [reduce using rule 24 (exp)]
    BOOL    [reduce using rule 26 (simpleExp)]
    BREAK   [reduce using rule 13 (stmt)]
    BREAK   [reduce using rule 24 (exp)]
    BREAK   [reduce using rule 26 (simpleExp)]
    NOT     [reduce using rule 13 (stmt)]
    NOT     [reduce using rule 24 (exp)]
    NOT     [reduce using rule 26 (simpleExp)]
    IF      [reduce using rule 13 (stmt)]
    IF      [reduce using rule 24 (exp)]
    IF      [reduce using rule 26 (simpleExp)]
    WHILE   [reduce using rule 13 (stmt)]
    WHILE   [reduce using rule 24 (exp)]
    WHILE   [reduce using rule 26 (simpleExp)]
    TRUE    [reduce using rule 13 (stmt)]
    TRUE    [reduce using rule 24 (exp)]
    TRUE    [reduce using rule 26 (simpleExp)]
    FALSE   [reduce using rule 13 (stmt)]
    FALSE   [reduce using rule 24 (exp)]
    FALSE   [reduce using rule 26 (simpleExp)]
    RETURN  [reduce using rule 13 (stmt)]
    RETURN  [reduce using rule 24 (exp)]
    RETURN  [reduce using rule 26 (simpleExp)]
    INT     [reduce using rule 13 (stmt)]
    INT     [reduce using rule 24 (exp)]
    INT     [reduce using rule 26 (simpleExp)]
    '-'     [reduce using rule 13 (stmt)]
    '-'     [reduce using rule 24 (exp)]
    '-'     [reduce using rule 26 (simpleExp)]

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 13

    1 program: typeSpec . varDeclId ':' simpleExp ';' '\n'

    ID  shift, and go to state 36

    varDeclId  go to state 37


State 14

    2 program: stmt .

    $default  reduce using rule 2 (program)


State 15

   12 stmt: exp .

    $default  reduce using rule 12 (stmt)


State 16

   25 exp: simpleExp .

    $default  reduce using rule 25 (exp)


State 17

    4 program: boolExp . '\n'
   27 simpleExp: boolExp .
   29 boolExp: boolExp . OR boolExp
   30        | boolExp . AND unaryRelExp

    AND   shift, and go to state 38
    OR    shift, and go to state 39
    '\n'  shift, and go to state 40

    $default  reduce using rule 27 (simpleExp)


State 18

   31 boolExp: unaryRelExp .

    $default  reduce using rule 31 (boolExp)


State 19

    5 program: sumExp . '\n'
   33 unaryRelExp: sumExp . relOp sumExp
   42 sumExp: sumExp . sumOp mulExp

    EQ    shift, and go to state 41
    NEQ   shift, and go to state 42
    GREQ  shift, and go to state 43
    GR    shift, and go to state 44
    SM    shift, and go to state 45
    SMEQ  shift, and go to state 46
    '-'   shift, and go to state 47
    '+'   shift, and go to state 48
    '\n'  shift, and go to state 49

    relOp  go to state 50
    sumOp  go to state 51


State 20

    6 program: mulExp . '\n'
   43 sumExp: mulExp .
   46 mulExp: mulExp . mulOp unaryExp

    '*'   shift, and go to state 52
    '/'   shift, and go to state 53
    '\n'  shift, and go to state 54

    '\n'      [reduce using rule 43 (sumExp)]
    $default  reduce using rule 43 (sumExp)

    mulOp  go to state 55


State 21

   28 simpleExp: unaryExp .
   47 mulExp: unaryExp .

    EQ        reduce using rule 47 (mulExp)
    NEQ       reduce using rule 47 (mulExp)
    GREQ      reduce using rule 47 (mulExp)
    GR        reduce using rule 47 (mulExp)
    SM        reduce using rule 47 (mulExp)
    SMEQ      reduce using rule 47 (mulExp)
    '-'       reduce using rule 28 (simpleExp)
    '-'       [reduce using rule 47 (mulExp)]
    '+'       reduce using rule 47 (mulExp)
    '*'       reduce using rule 47 (mulExp)
    '/'       reduce using rule 47 (mulExp)
    '\n'      reduce using rule 47 (mulExp)
    $default  reduce using rule 28 (simpleExp)


State 22

   17 stmt: BREAK ';' .

    $default  reduce using rule 17 (stmt)


State 23

   32 unaryRelExp: NOT unaryRelExp .

    $default  reduce using rule 32 (unaryRelExp)


State 24

   33 unaryRelExp: sumExp . relOp sumExp
   42 sumExp: sumExp . sumOp mulExp

    EQ    shift, and go to state 41
    NEQ   shift, and go to state 42
    GREQ  shift, and go to state 43
    GR    shift, and go to state 44
    SM    shift, and go to state 45
    SMEQ  shift, and go to state 46
    '-'   shift, and go to state 47
    '+'   shift, and go to state 48

    relOp  go to state 50
    sumOp  go to state 51


State 25

   43 sumExp: mulExp .
   46 mulExp: mulExp . mulOp unaryExp

    '*'  shift, and go to state 52
    '/'  shift, and go to state 53

    $default  reduce using rule 43 (sumExp)

    mulOp  go to state 55


State 26

   47 mulExp: unaryExp .

    $default  reduce using rule 47 (mulExp)


State 27

   14 stmt: IF '(' . simpleExp ')' compoundStmt
   15     | IF '(' . simpleExp ')' compoundStmt ELSE compoundStmt

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    $default  reduce using rule 26 (simpleExp)

    simpleExp    go to state 56
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 28

   16 stmt: WHILE simpleExp . DO compoundStmt

    DO  shift, and go to state 57


State 29

   27 simpleExp: boolExp .
   29 boolExp: boolExp . OR boolExp
   30        | boolExp . AND unaryRelExp

    AND  shift, and go to state 38
    OR   shift, and go to state 39

    $default  reduce using rule 27 (simpleExp)


State 30

   18 stmt: RETURN ';' .

    $default  reduce using rule 18 (stmt)


State 31

    3 program: program . program
   24 exp: program .

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    NUM       [reduce using rule 13 (stmt)]
    NUM       [reduce using rule 24 (exp)]
    NUM       [reduce using rule 26 (simpleExp)]
    BOOL      [reduce using rule 13 (stmt)]
    BOOL      [reduce using rule 24 (exp)]
    BOOL      [reduce using rule 26 (simpleExp)]
    BREAK     [reduce using rule 13 (stmt)]
    BREAK     [reduce using rule 24 (exp)]
    BREAK     [reduce using rule 26 (simpleExp)]
    NOT       [reduce using rule 13 (stmt)]
    NOT       [reduce using rule 24 (exp)]
    NOT       [reduce using rule 26 (simpleExp)]
    IF        [reduce using rule 13 (stmt)]
    IF        [reduce using rule 24 (exp)]
    IF        [reduce using rule 26 (simpleExp)]
    WHILE     [reduce using rule 13 (stmt)]
    WHILE     [reduce using rule 24 (exp)]
    WHILE     [reduce using rule 26 (simpleExp)]
    TRUE      [reduce using rule 13 (stmt)]
    TRUE      [reduce using rule 24 (exp)]
    TRUE      [reduce using rule 26 (simpleExp)]
    FALSE     [reduce using rule 13 (stmt)]
    FALSE     [reduce using rule 24 (exp)]
    FALSE     [reduce using rule 26 (simpleExp)]
    RETURN    [reduce using rule 13 (stmt)]
    RETURN    [reduce using rule 24 (exp)]
    RETURN    [reduce using rule 26 (simpleExp)]
    INT       [reduce using rule 13 (stmt)]
    INT       [reduce using rule 24 (exp)]
    INT       [reduce using rule 26 (simpleExp)]
    '-'       [reduce using rule 13 (stmt)]
    '-'       [reduce using rule 24 (exp)]
    '-'       [reduce using rule 26 (simpleExp)]
    ';'       reduce using rule 13 (stmt)
    ';'       [reduce using rule 24 (exp)]
    ';'       [reduce using rule 26 (simpleExp)]
    '}'       reduce using rule 13 (stmt)
    '}'       [reduce using rule 24 (exp)]
    '}'       [reduce using rule 26 (simpleExp)]
    $default  reduce using rule 13 (stmt)

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 32

   12 stmt: exp .
   19     | RETURN exp . ';'

    ';'  shift, and go to state 58

    ';'       [reduce using rule 12 (stmt)]
    $default  reduce using rule 12 (stmt)


State 33

   50 unaryExp: '-' NUM .

    $default  reduce using rule 50 (unaryExp)


State 34

    0 $accept: program $end .

    $default  accept


State 35

    3 program: program . program
    3        | program program .
   24 exp: program .

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end      reduce using rule 3 (program)
    $end      [reduce using rule 13 (stmt)]
    $end      [reduce using rule 24 (exp)]
    $end      [reduce using rule 26 (simpleExp)]
    NUM       [reduce using rule 3 (program)]
    NUM       [reduce using rule 13 (stmt)]
    NUM       [reduce using rule 24 (exp)]
    NUM       [reduce using rule 26 (simpleExp)]
    BOOL      [reduce using rule 3 (program)]
    BOOL      [reduce using rule 13 (stmt)]
    BOOL      [reduce using rule 24 (exp)]
    BOOL      [reduce using rule 26 (simpleExp)]
    BREAK     [reduce using rule 3 (program)]
    BREAK     [reduce using rule 13 (stmt)]
    BREAK     [reduce using rule 24 (exp)]
    BREAK     [reduce using rule 26 (simpleExp)]
    NOT       [reduce using rule 3 (program)]
    NOT       [reduce using rule 13 (stmt)]
    NOT       [reduce using rule 24 (exp)]
    NOT       [reduce using rule 26 (simpleExp)]
    IF        [reduce using rule 3 (program)]
    IF        [reduce using rule 13 (stmt)]
    IF        [reduce using rule 24 (exp)]
    IF        [reduce using rule 26 (simpleExp)]
    WHILE     [reduce using rule 3 (program)]
    WHILE     [reduce using rule 13 (stmt)]
    WHILE     [reduce using rule 24 (exp)]
    WHILE     [reduce using rule 26 (simpleExp)]
    TRUE      [reduce using rule 3 (program)]
    TRUE      [reduce using rule 13 (stmt)]
    TRUE      [reduce using rule 24 (exp)]
    TRUE      [reduce using rule 26 (simpleExp)]
    FALSE     [reduce using rule 3 (program)]
    FALSE     [reduce using rule 13 (stmt)]
    FALSE     [reduce using rule 24 (exp)]
    FALSE     [reduce using rule 26 (simpleExp)]
    RETURN    [reduce using rule 3 (program)]
    RETURN    [reduce using rule 13 (stmt)]
    RETURN    [reduce using rule 24 (exp)]
    RETURN    [reduce using rule 26 (simpleExp)]
    INT       [reduce using rule 3 (program)]
    INT       [reduce using rule 13 (stmt)]
    INT       [reduce using rule 24 (exp)]
    INT       [reduce using rule 26 (simpleExp)]
    '-'       [reduce using rule 3 (program)]
    '-'       [reduce using rule 13 (stmt)]
    '-'       [reduce using rule 24 (exp)]
    '-'       [reduce using rule 26 (simpleExp)]
    ';'       reduce using rule 3 (program)
    ';'       [reduce using rule 13 (stmt)]
    ';'       [reduce using rule 24 (exp)]
    ';'       [reduce using rule 26 (simpleExp)]
    '}'       reduce using rule 3 (program)
    '}'       [reduce using rule 13 (stmt)]
    '}'       [reduce using rule 24 (exp)]
    '}'       [reduce using rule 26 (simpleExp)]
    $default  reduce using rule 3 (program)

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 36

    8 varDeclId: ID .
    9          | ID .

    ':'       reduce using rule 8 (varDeclId)
    ':'       [reduce using rule 9 (varDeclId)]
    $default  reduce using rule 8 (varDeclId)


State 37

    1 program: typeSpec varDeclId . ':' simpleExp ';' '\n'

    ':'  shift, and go to state 59


State 38

   30 boolExp: boolExp AND . unaryRelExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    unaryRelExp  go to state 60
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 39

   29 boolExp: boolExp OR . boolExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    boolExp      go to state 61
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 40

    4 program: boolExp '\n' .

    $default  reduce using rule 4 (program)


State 41

   40 relOp: EQ .

    $default  reduce using rule 40 (relOp)


State 42

   41 relOp: NEQ .

    $default  reduce using rule 41 (relOp)


State 43

   37 relOp: GREQ .

    $default  reduce using rule 37 (relOp)


State 44

   36 relOp: GR .

    $default  reduce using rule 36 (relOp)


State 45

   38 relOp: SM .

    $default  reduce using rule 38 (relOp)


State 46

   39 relOp: SMEQ .

    $default  reduce using rule 39 (relOp)


State 47

   45 sumOp: '-' .

    $default  reduce using rule 45 (sumOp)


State 48

   44 sumOp: '+' .

    $default  reduce using rule 44 (sumOp)


State 49

    5 program: sumExp '\n' .

    $default  reduce using rule 5 (program)


State 50

   33 unaryRelExp: sumExp relOp . sumExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    sumExp    go to state 62
    mulExp    go to state 25
    unaryExp  go to state 26


State 51

   42 sumExp: sumExp sumOp . mulExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    mulExp    go to state 63
    unaryExp  go to state 26


State 52

   48 mulOp: '*' .

    $default  reduce using rule 48 (mulOp)


State 53

   49 mulOp: '/' .

    $default  reduce using rule 49 (mulOp)


State 54

    6 program: mulExp '\n' .

    $default  reduce using rule 6 (program)


State 55

   46 mulExp: mulExp mulOp . unaryExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    unaryExp  go to state 64


State 56

   14 stmt: IF '(' simpleExp . ')' compoundStmt
   15     | IF '(' simpleExp . ')' compoundStmt ELSE compoundStmt

    ')'  shift, and go to state 65


State 57

   16 stmt: WHILE simpleExp DO . compoundStmt

    '{'  shift, and go to state 66

    compoundStmt  go to state 67


State 58

   19 stmt: RETURN exp ';' .

    $default  reduce using rule 19 (stmt)


State 59

    1 program: typeSpec varDeclId ':' . simpleExp ';' '\n'

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    $default  reduce using rule 26 (simpleExp)

    simpleExp    go to state 68
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 60

   30 boolExp: boolExp AND unaryRelExp .

    $default  reduce using rule 30 (boolExp)


State 61

   29 boolExp: boolExp . OR boolExp
   29        | boolExp OR boolExp .
   30        | boolExp . AND unaryRelExp

    $default  reduce using rule 29 (boolExp)


State 62

   33 unaryRelExp: sumExp relOp sumExp .
   42 sumExp: sumExp . sumOp mulExp

    '-'  shift, and go to state 47
    '+'  shift, and go to state 48

    '-'       [reduce using rule 33 (unaryRelExp)]
    $default  reduce using rule 33 (unaryRelExp)

    sumOp  go to state 51


State 63

   42 sumExp: sumExp sumOp mulExp .
   46 mulExp: mulExp . mulOp unaryExp

    '*'  shift, and go to state 52
    '/'  shift, and go to state 53

    $default  reduce using rule 42 (sumExp)

    mulOp  go to state 55


State 64

   46 mulExp: mulExp mulOp unaryExp .

    $default  reduce using rule 46 (mulExp)


State 65

   14 stmt: IF '(' simpleExp ')' . compoundStmt
   15     | IF '(' simpleExp ')' . compoundStmt ELSE compoundStmt

    '{'  shift, and go to state 66

    compoundStmt  go to state 69


State 66

   20 compoundStmt: '{' . localDecls stmt '}'

    BOOL  shift, and go to state 2
    INT   shift, and go to state 10

    typeSpec       go to state 70
    localDecls     go to state 71
    scopedVarDecl  go to state 72


State 67

   16 stmt: WHILE simpleExp DO compoundStmt .

    $default  reduce using rule 16 (stmt)


State 68

    1 program: typeSpec varDeclId ':' simpleExp . ';' '\n'

    ';'  shift, and go to state 73


State 69

   14 stmt: IF '(' simpleExp ')' compoundStmt .
   15     | IF '(' simpleExp ')' compoundStmt . ELSE compoundStmt

    ELSE  shift, and go to state 74

    $default  reduce using rule 14 (stmt)


State 70

   23 scopedVarDecl: typeSpec . varDeclInit

    $default  reduce using rule 7 (varDeclInit)

    varDeclInit  go to state 75


State 71

   20 compoundStmt: '{' localDecls . stmt '}'
   21 localDecls: localDecls . scopedVarDecl

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    NUM       [reduce using rule 13 (stmt)]
    NUM       [reduce using rule 26 (simpleExp)]
    BOOL      [reduce using rule 13 (stmt)]
    BOOL      [reduce using rule 26 (simpleExp)]
    BREAK     [reduce using rule 13 (stmt)]
    BREAK     [reduce using rule 26 (simpleExp)]
    NOT       [reduce using rule 13 (stmt)]
    NOT       [reduce using rule 26 (simpleExp)]
    IF        [reduce using rule 13 (stmt)]
    IF        [reduce using rule 26 (simpleExp)]
    WHILE     [reduce using rule 13 (stmt)]
    WHILE     [reduce using rule 26 (simpleExp)]
    TRUE      [reduce using rule 13 (stmt)]
    TRUE      [reduce using rule 26 (simpleExp)]
    FALSE     [reduce using rule 13 (stmt)]
    FALSE     [reduce using rule 26 (simpleExp)]
    RETURN    [reduce using rule 13 (stmt)]
    RETURN    [reduce using rule 26 (simpleExp)]
    INT       [reduce using rule 13 (stmt)]
    INT       [reduce using rule 26 (simpleExp)]
    '-'       [reduce using rule 13 (stmt)]
    '-'       [reduce using rule 26 (simpleExp)]
    '}'       reduce using rule 13 (stmt)
    '}'       [reduce using rule 26 (simpleExp)]
    $default  reduce using rule 13 (stmt)

    program        go to state 31
    typeSpec       go to state 76
    stmt           go to state 77
    scopedVarDecl  go to state 78
    exp            go to state 15
    simpleExp      go to state 16
    boolExp        go to state 17
    unaryRelExp    go to state 18
    sumExp         go to state 19
    mulExp         go to state 20
    unaryExp       go to state 21


State 72

   22 localDecls: scopedVarDecl .

    $default  reduce using rule 22 (localDecls)


State 73

    1 program: typeSpec varDeclId ':' simpleExp ';' . '\n'

    '\n'  shift, and go to state 79


State 74

   15 stmt: IF '(' simpleExp ')' compoundStmt ELSE . compoundStmt

    '{'  shift, and go to state 66

    compoundStmt  go to state 80


State 75

   23 scopedVarDecl: typeSpec varDeclInit .

    $default  reduce using rule 23 (scopedVarDecl)


State 76

    1 program: typeSpec . varDeclId ':' simpleExp ';' '\n'
   23 scopedVarDecl: typeSpec . varDeclInit

    ID  shift, and go to state 36

    $default  reduce using rule 7 (varDeclInit)

    varDeclInit  go to state 75
    varDeclId    go to state 37


State 77

    2 program: stmt .
   20 compoundStmt: '{' localDecls stmt . '}'

    '}'  shift, and go to state 81

    '}'       [reduce using rule 2 (program)]
    $default  reduce using rule 2 (program)


State 78

   21 localDecls: localDecls scopedVarDecl .

    $default  reduce using rule 21 (localDecls)


State 79

    1 program: typeSpec varDeclId ':' simpleExp ';' '\n' .

    $default  reduce using rule 1 (program)


State 80

   15 stmt: IF '(' simpleExp ')' compoundStmt ELSE compoundStmt .

    $default  reduce using rule 15 (stmt)


State 81

   20 compoundStmt: '{' localDecls stmt '}' .

    $default  reduce using rule 20 (compoundStmt)
