Nonterminals useless in grammar

    intExp


Terminals unused in grammar

    UMINUS


Rules useless in parser due to conflicts

   10 varDeclId: ID

   25 exp: program


State 0 conflicts: 11 shift/reduce, 12 reduce/reduce
State 9 conflicts: 12 shift/reduce, 12 reduce/reduce
State 12 conflicts: 12 shift/reduce, 24 reduce/reduce
State 20 conflicts: 1 shift/reduce
State 21 conflicts: 1 reduce/reduce
State 31 conflicts: 11 shift/reduce, 26 reduce/reduce
State 32 conflicts: 1 shift/reduce
State 35 conflicts: 11 shift/reduce, 42 reduce/reduce
State 36 conflicts: 14 reduce/reduce
State 61 conflicts: 5 shift/reduce
State 64 conflicts: 1 shift/reduce
State 74 conflicts: 11 shift/reduce, 12 reduce/reduce
State 79 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: typeSpec varDeclInit ';' '\n'
    2        | stmt
    3        | program program
    4        | boolExp '\n'
    5        | sumExp '\n'
    6        | mulExp '\n'

    7 varDeclInit: varDeclId
    8            | varDeclId ':' simpleExp

    9 varDeclId: ID
   10          | ID

   11 typeSpec: INT
   12         | BOOL

   13 stmt: exp
   14     | %empty
   15     | IF '(' simpleExp ')' compoundStmt
   16     | IF '(' simpleExp ')' compoundStmt ELSE compoundStmt
   17     | WHILE simpleExp DO compoundStmt
   18     | BREAK ';'
   19     | RETURN ';'
   20     | RETURN exp ';'

   21 compoundStmt: '{' localDecls stmt '}'

   22 localDecls: localDecls scopedVarDecl
   23           | scopedVarDecl

   24 scopedVarDecl: typeSpec varDeclInit

   25 exp: program
   26    | simpleExp

   27 simpleExp: %empty
   28          | boolExp
   29          | unaryExp

   30 boolExp: boolExp OR boolExp
   31        | boolExp AND unaryRelExp
   32        | unaryRelExp

   33 unaryRelExp: NOT unaryRelExp
   34            | sumExp relOp sumExp
   35            | TRUE
   36            | FALSE

   37 relOp: GR
   38      | GREQ
   39      | SM
   40      | SMEQ
   41      | EQ
   42      | NEQ

   43 sumExp: sumExp sumOp mulExp
   44       | mulExp

   45 sumOp: '+'
   46      | '-'

   47 mulExp: mulExp mulOp unaryExp
   48       | unaryExp

   49 mulOp: '*'
   50      | '/'

   51 unaryExp: '-' NUM
   52         | NUM


Terminals, with rules where they appear

    $end (0) 0
    '\n' (10) 1 4 5 6
    '(' (40) 15 16
    ')' (41) 15 16
    '*' (42) 49
    '+' (43) 45
    '-' (45) 46 51
    '/' (47) 50
    ':' (58) 8
    ';' (59) 1 18 19 20
    '{' (123) 21
    '}' (125) 21
    error (256)
    NUM <integer> (258) 51 52
    BOOL <integer> (259) 12
    ID <lexeme> (260) 9 10
    BREAK (261) 18
    AND (262) 31
    OR (263) 30
    NOT (264) 33
    IF (265) 15 16
    ELSE (266) 16
    WHILE (267) 17
    DO (268) 17
    EQ (269) 41
    NEQ (270) 42
    GREQ (271) 38
    GR (272) 37
    SM (273) 39
    SMEQ (274) 40
    TRUE <boolean> (275) 35
    FALSE <boolean> (276) 36
    RETURN (277) 19 20
    INT <integer> (278) 11
    UMINUS (279)


Nonterminals, with rules where they appear

    $accept (36)
        on left: 0
    program (37)
        on left: 1 2 3 4 5 6
        on right: 0 3 25
    varDeclInit <lexeme> (38)
        on left: 7 8
        on right: 1 24
    varDeclId <lexeme> (39)
        on left: 9 10
        on right: 7 8
    typeSpec <lexeme> (40)
        on left: 11 12
        on right: 1 24
    stmt (41)
        on left: 13 14 15 16 17 18 19 20
        on right: 2 21
    compoundStmt (42)
        on left: 21
        on right: 15 16 17
    localDecls (43)
        on left: 22 23
        on right: 21 22
    scopedVarDecl (44)
        on left: 24
        on right: 22 23
    exp (45)
        on left: 25 26
        on right: 13 20
    simpleExp <integer> (46)
        on left: 27 28 29
        on right: 8 15 16 17 26
    boolExp <boolean> (47)
        on left: 30 31 32
        on right: 4 28 30 31
    unaryRelExp <boolean> (48)
        on left: 33 34 35 36
        on right: 31 32 33
    relOp <integer> (49)
        on left: 37 38 39 40 41 42
        on right: 34
    sumExp <integer> (50)
        on left: 43 44
        on right: 5 34 43
    sumOp <integer> (51)
        on left: 45 46
        on right: 43
    mulExp <integer> (52)
        on left: 47 48
        on right: 6 43 44 47
    mulOp <integer> (53)
        on left: 49 50
        on right: 47
    unaryExp <integer> (54)
        on left: 51 52
        on right: 29 47 48


State 0

    0 $accept: . program $end

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end      reduce using rule 14 (stmt)
    $end      [reduce using rule 27 (simpleExp)]
    NUM       [reduce using rule 14 (stmt)]
    NUM       [reduce using rule 27 (simpleExp)]
    BOOL      [reduce using rule 14 (stmt)]
    BOOL      [reduce using rule 27 (simpleExp)]
    BREAK     [reduce using rule 14 (stmt)]
    BREAK     [reduce using rule 27 (simpleExp)]
    NOT       [reduce using rule 14 (stmt)]
    NOT       [reduce using rule 27 (simpleExp)]
    IF        [reduce using rule 14 (stmt)]
    IF        [reduce using rule 27 (simpleExp)]
    WHILE     [reduce using rule 14 (stmt)]
    WHILE     [reduce using rule 27 (simpleExp)]
    TRUE      [reduce using rule 14 (stmt)]
    TRUE      [reduce using rule 27 (simpleExp)]
    FALSE     [reduce using rule 14 (stmt)]
    FALSE     [reduce using rule 27 (simpleExp)]
    RETURN    [reduce using rule 14 (stmt)]
    RETURN    [reduce using rule 27 (simpleExp)]
    INT       [reduce using rule 14 (stmt)]
    INT       [reduce using rule 27 (simpleExp)]
    '-'       [reduce using rule 14 (stmt)]
    '-'       [reduce using rule 27 (simpleExp)]
    $default  reduce using rule 14 (stmt)

    program      go to state 12
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 1

   52 unaryExp: NUM .

    $default  reduce using rule 52 (unaryExp)


State 2

   12 typeSpec: BOOL .

    $default  reduce using rule 12 (typeSpec)


State 3

   18 stmt: BREAK . ';'

    ';'  shift, and go to state 22


State 4

   33 unaryRelExp: NOT . unaryRelExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    unaryRelExp  go to state 23
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 5

   15 stmt: IF . '(' simpleExp ')' compoundStmt
   16     | IF . '(' simpleExp ')' compoundStmt ELSE compoundStmt

    '('  shift, and go to state 27


State 6

   17 stmt: WHILE . simpleExp DO compoundStmt

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    $default  reduce using rule 27 (simpleExp)

    simpleExp    go to state 28
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 7

   35 unaryRelExp: TRUE .

    $default  reduce using rule 35 (unaryRelExp)


State 8

   36 unaryRelExp: FALSE .

    $default  reduce using rule 36 (unaryRelExp)


State 9

   19 stmt: RETURN . ';'
   20     | RETURN . exp ';'

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11
    ';'     shift, and go to state 30

    NUM     [reduce using rule 14 (stmt)]
    NUM     [reduce using rule 27 (simpleExp)]
    BOOL    [reduce using rule 14 (stmt)]
    BOOL    [reduce using rule 27 (simpleExp)]
    BREAK   [reduce using rule 14 (stmt)]
    BREAK   [reduce using rule 27 (simpleExp)]
    NOT     [reduce using rule 14 (stmt)]
    NOT     [reduce using rule 27 (simpleExp)]
    IF      [reduce using rule 14 (stmt)]
    IF      [reduce using rule 27 (simpleExp)]
    WHILE   [reduce using rule 14 (stmt)]
    WHILE   [reduce using rule 27 (simpleExp)]
    TRUE    [reduce using rule 14 (stmt)]
    TRUE    [reduce using rule 27 (simpleExp)]
    FALSE   [reduce using rule 14 (stmt)]
    FALSE   [reduce using rule 27 (simpleExp)]
    RETURN  [reduce using rule 14 (stmt)]
    RETURN  [reduce using rule 27 (simpleExp)]
    INT     [reduce using rule 14 (stmt)]
    INT     [reduce using rule 27 (simpleExp)]
    '-'     [reduce using rule 14 (stmt)]
    '-'     [reduce using rule 27 (simpleExp)]
    ';'     [reduce using rule 14 (stmt)]
    ';'     [reduce using rule 27 (simpleExp)]

    program      go to state 31
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 32
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 10

   11 typeSpec: INT .

    $default  reduce using rule 11 (typeSpec)


State 11

   51 unaryExp: '-' . NUM

    NUM  shift, and go to state 33


State 12

    0 $accept: program . $end
    3 program: program . program
   25 exp: program .

    $end    shift, and go to state 34
    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end    [reduce using rule 14 (stmt)]
    $end    [reduce using rule 25 (exp)]
    $end    [reduce using rule 27 (simpleExp)]
    NUM     [reduce using rule 14 (stmt)]
    NUM     [reduce using rule 25 (exp)]
    NUM     [reduce using rule 27 (simpleExp)]
    BOOL    [reduce using rule 14 (stmt)]
    BOOL    [reduce using rule 25 (exp)]
    BOOL    [reduce using rule 27 (simpleExp)]
    BREAK   [reduce using rule 14 (stmt)]
    BREAK   [reduce using rule 25 (exp)]
    BREAK   [reduce using rule 27 (simpleExp)]
    NOT     [reduce using rule 14 (stmt)]
    NOT     [reduce using rule 25 (exp)]
    NOT     [reduce using rule 27 (simpleExp)]
    IF      [reduce using rule 14 (stmt)]
    IF      [reduce using rule 25 (exp)]
    IF      [reduce using rule 27 (simpleExp)]
    WHILE   [reduce using rule 14 (stmt)]
    WHILE   [reduce using rule 25 (exp)]
    WHILE   [reduce using rule 27 (simpleExp)]
    TRUE    [reduce using rule 14 (stmt)]
    TRUE    [reduce using rule 25 (exp)]
    TRUE    [reduce using rule 27 (simpleExp)]
    FALSE   [reduce using rule 14 (stmt)]
    FALSE   [reduce using rule 25 (exp)]
    FALSE   [reduce using rule 27 (simpleExp)]
    RETURN  [reduce using rule 14 (stmt)]
    RETURN  [reduce using rule 25 (exp)]
    RETURN  [reduce using rule 27 (simpleExp)]
    INT     [reduce using rule 14 (stmt)]
    INT     [reduce using rule 25 (exp)]
    INT     [reduce using rule 27 (simpleExp)]
    '-'     [reduce using rule 14 (stmt)]
    '-'     [reduce using rule 25 (exp)]
    '-'     [reduce using rule 27 (simpleExp)]

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 13

    1 program: typeSpec . varDeclInit ';' '\n'

    ID  shift, and go to state 36

    varDeclInit  go to state 37
    varDeclId    go to state 38


State 14

    2 program: stmt .

    $default  reduce using rule 2 (program)


State 15

   13 stmt: exp .

    $default  reduce using rule 13 (stmt)


State 16

   26 exp: simpleExp .

    $default  reduce using rule 26 (exp)


State 17

    4 program: boolExp . '\n'
   28 simpleExp: boolExp .
   30 boolExp: boolExp . OR boolExp
   31        | boolExp . AND unaryRelExp

    AND   shift, and go to state 39
    OR    shift, and go to state 40
    '\n'  shift, and go to state 41

    $default  reduce using rule 28 (simpleExp)


State 18

   32 boolExp: unaryRelExp .

    $default  reduce using rule 32 (boolExp)


State 19

    5 program: sumExp . '\n'
   34 unaryRelExp: sumExp . relOp sumExp
   43 sumExp: sumExp . sumOp mulExp

    EQ    shift, and go to state 42
    NEQ   shift, and go to state 43
    GREQ  shift, and go to state 44
    GR    shift, and go to state 45
    SM    shift, and go to state 46
    SMEQ  shift, and go to state 47
    '-'   shift, and go to state 48
    '+'   shift, and go to state 49
    '\n'  shift, and go to state 50

    relOp  go to state 51
    sumOp  go to state 52


State 20

    6 program: mulExp . '\n'
   44 sumExp: mulExp .
   47 mulExp: mulExp . mulOp unaryExp

    '*'   shift, and go to state 53
    '/'   shift, and go to state 54
    '\n'  shift, and go to state 55

    '\n'      [reduce using rule 44 (sumExp)]
    $default  reduce using rule 44 (sumExp)

    mulOp  go to state 56


State 21

   29 simpleExp: unaryExp .
   48 mulExp: unaryExp .

    EQ        reduce using rule 48 (mulExp)
    NEQ       reduce using rule 48 (mulExp)
    GREQ      reduce using rule 48 (mulExp)
    GR        reduce using rule 48 (mulExp)
    SM        reduce using rule 48 (mulExp)
    SMEQ      reduce using rule 48 (mulExp)
    '-'       reduce using rule 29 (simpleExp)
    '-'       [reduce using rule 48 (mulExp)]
    '+'       reduce using rule 48 (mulExp)
    '*'       reduce using rule 48 (mulExp)
    '/'       reduce using rule 48 (mulExp)
    '\n'      reduce using rule 48 (mulExp)
    $default  reduce using rule 29 (simpleExp)


State 22

   18 stmt: BREAK ';' .

    $default  reduce using rule 18 (stmt)


State 23

   33 unaryRelExp: NOT unaryRelExp .

    $default  reduce using rule 33 (unaryRelExp)


State 24

   34 unaryRelExp: sumExp . relOp sumExp
   43 sumExp: sumExp . sumOp mulExp

    EQ    shift, and go to state 42
    NEQ   shift, and go to state 43
    GREQ  shift, and go to state 44
    GR    shift, and go to state 45
    SM    shift, and go to state 46
    SMEQ  shift, and go to state 47
    '-'   shift, and go to state 48
    '+'   shift, and go to state 49

    relOp  go to state 51
    sumOp  go to state 52


State 25

   44 sumExp: mulExp .
   47 mulExp: mulExp . mulOp unaryExp

    '*'  shift, and go to state 53
    '/'  shift, and go to state 54

    $default  reduce using rule 44 (sumExp)

    mulOp  go to state 56


State 26

   48 mulExp: unaryExp .

    $default  reduce using rule 48 (mulExp)


State 27

   15 stmt: IF '(' . simpleExp ')' compoundStmt
   16     | IF '(' . simpleExp ')' compoundStmt ELSE compoundStmt

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    $default  reduce using rule 27 (simpleExp)

    simpleExp    go to state 57
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 28

   17 stmt: WHILE simpleExp . DO compoundStmt

    DO  shift, and go to state 58


State 29

   28 simpleExp: boolExp .
   30 boolExp: boolExp . OR boolExp
   31        | boolExp . AND unaryRelExp

    AND  shift, and go to state 39
    OR   shift, and go to state 40

    $default  reduce using rule 28 (simpleExp)


State 30

   19 stmt: RETURN ';' .

    $default  reduce using rule 19 (stmt)


State 31

    3 program: program . program
   25 exp: program .

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    NUM       [reduce using rule 14 (stmt)]
    NUM       [reduce using rule 25 (exp)]
    NUM       [reduce using rule 27 (simpleExp)]
    BOOL      [reduce using rule 14 (stmt)]
    BOOL      [reduce using rule 25 (exp)]
    BOOL      [reduce using rule 27 (simpleExp)]
    BREAK     [reduce using rule 14 (stmt)]
    BREAK     [reduce using rule 25 (exp)]
    BREAK     [reduce using rule 27 (simpleExp)]
    NOT       [reduce using rule 14 (stmt)]
    NOT       [reduce using rule 25 (exp)]
    NOT       [reduce using rule 27 (simpleExp)]
    IF        [reduce using rule 14 (stmt)]
    IF        [reduce using rule 25 (exp)]
    IF        [reduce using rule 27 (simpleExp)]
    WHILE     [reduce using rule 14 (stmt)]
    WHILE     [reduce using rule 25 (exp)]
    WHILE     [reduce using rule 27 (simpleExp)]
    TRUE      [reduce using rule 14 (stmt)]
    TRUE      [reduce using rule 25 (exp)]
    TRUE      [reduce using rule 27 (simpleExp)]
    FALSE     [reduce using rule 14 (stmt)]
    FALSE     [reduce using rule 25 (exp)]
    FALSE     [reduce using rule 27 (simpleExp)]
    RETURN    [reduce using rule 14 (stmt)]
    RETURN    [reduce using rule 25 (exp)]
    RETURN    [reduce using rule 27 (simpleExp)]
    INT       [reduce using rule 14 (stmt)]
    INT       [reduce using rule 25 (exp)]
    INT       [reduce using rule 27 (simpleExp)]
    '-'       [reduce using rule 14 (stmt)]
    '-'       [reduce using rule 25 (exp)]
    '-'       [reduce using rule 27 (simpleExp)]
    ';'       reduce using rule 14 (stmt)
    ';'       [reduce using rule 25 (exp)]
    ';'       [reduce using rule 27 (simpleExp)]
    '}'       reduce using rule 14 (stmt)
    '}'       [reduce using rule 25 (exp)]
    '}'       [reduce using rule 27 (simpleExp)]
    $default  reduce using rule 14 (stmt)

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 32

   13 stmt: exp .
   20     | RETURN exp . ';'

    ';'  shift, and go to state 59

    ';'       [reduce using rule 13 (stmt)]
    $default  reduce using rule 13 (stmt)


State 33

   51 unaryExp: '-' NUM .

    $default  reduce using rule 51 (unaryExp)


State 34

    0 $accept: program $end .

    $default  accept


State 35

    3 program: program . program
    3        | program program .
   25 exp: program .

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    $end      reduce using rule 3 (program)
    $end      [reduce using rule 14 (stmt)]
    $end      [reduce using rule 25 (exp)]
    $end      [reduce using rule 27 (simpleExp)]
    NUM       [reduce using rule 3 (program)]
    NUM       [reduce using rule 14 (stmt)]
    NUM       [reduce using rule 25 (exp)]
    NUM       [reduce using rule 27 (simpleExp)]
    BOOL      [reduce using rule 3 (program)]
    BOOL      [reduce using rule 14 (stmt)]
    BOOL      [reduce using rule 25 (exp)]
    BOOL      [reduce using rule 27 (simpleExp)]
    BREAK     [reduce using rule 3 (program)]
    BREAK     [reduce using rule 14 (stmt)]
    BREAK     [reduce using rule 25 (exp)]
    BREAK     [reduce using rule 27 (simpleExp)]
    NOT       [reduce using rule 3 (program)]
    NOT       [reduce using rule 14 (stmt)]
    NOT       [reduce using rule 25 (exp)]
    NOT       [reduce using rule 27 (simpleExp)]
    IF        [reduce using rule 3 (program)]
    IF        [reduce using rule 14 (stmt)]
    IF        [reduce using rule 25 (exp)]
    IF        [reduce using rule 27 (simpleExp)]
    WHILE     [reduce using rule 3 (program)]
    WHILE     [reduce using rule 14 (stmt)]
    WHILE     [reduce using rule 25 (exp)]
    WHILE     [reduce using rule 27 (simpleExp)]
    TRUE      [reduce using rule 3 (program)]
    TRUE      [reduce using rule 14 (stmt)]
    TRUE      [reduce using rule 25 (exp)]
    TRUE      [reduce using rule 27 (simpleExp)]
    FALSE     [reduce using rule 3 (program)]
    FALSE     [reduce using rule 14 (stmt)]
    FALSE     [reduce using rule 25 (exp)]
    FALSE     [reduce using rule 27 (simpleExp)]
    RETURN    [reduce using rule 3 (program)]
    RETURN    [reduce using rule 14 (stmt)]
    RETURN    [reduce using rule 25 (exp)]
    RETURN    [reduce using rule 27 (simpleExp)]
    INT       [reduce using rule 3 (program)]
    INT       [reduce using rule 14 (stmt)]
    INT       [reduce using rule 25 (exp)]
    INT       [reduce using rule 27 (simpleExp)]
    '-'       [reduce using rule 3 (program)]
    '-'       [reduce using rule 14 (stmt)]
    '-'       [reduce using rule 25 (exp)]
    '-'       [reduce using rule 27 (simpleExp)]
    ';'       reduce using rule 3 (program)
    ';'       [reduce using rule 14 (stmt)]
    ';'       [reduce using rule 25 (exp)]
    ';'       [reduce using rule 27 (simpleExp)]
    '}'       reduce using rule 3 (program)
    '}'       [reduce using rule 14 (stmt)]
    '}'       [reduce using rule 25 (exp)]
    '}'       [reduce using rule 27 (simpleExp)]
    $default  reduce using rule 3 (program)

    program      go to state 35
    typeSpec     go to state 13
    stmt         go to state 14
    exp          go to state 15
    simpleExp    go to state 16
    boolExp      go to state 17
    unaryRelExp  go to state 18
    sumExp       go to state 19
    mulExp       go to state 20
    unaryExp     go to state 21


State 36

    9 varDeclId: ID .
   10          | ID .

    NUM       reduce using rule 9 (varDeclId)
    NUM       [reduce using rule 10 (varDeclId)]
    BOOL      reduce using rule 9 (varDeclId)
    BOOL      [reduce using rule 10 (varDeclId)]
    BREAK     reduce using rule 9 (varDeclId)
    BREAK     [reduce using rule 10 (varDeclId)]
    NOT       reduce using rule 9 (varDeclId)
    NOT       [reduce using rule 10 (varDeclId)]
    IF        reduce using rule 9 (varDeclId)
    IF        [reduce using rule 10 (varDeclId)]
    WHILE     reduce using rule 9 (varDeclId)
    WHILE     [reduce using rule 10 (varDeclId)]
    TRUE      reduce using rule 9 (varDeclId)
    TRUE      [reduce using rule 10 (varDeclId)]
    FALSE     reduce using rule 9 (varDeclId)
    FALSE     [reduce using rule 10 (varDeclId)]
    RETURN    reduce using rule 9 (varDeclId)
    RETURN    [reduce using rule 10 (varDeclId)]
    INT       reduce using rule 9 (varDeclId)
    INT       [reduce using rule 10 (varDeclId)]
    '-'       reduce using rule 9 (varDeclId)
    '-'       [reduce using rule 10 (varDeclId)]
    ';'       reduce using rule 9 (varDeclId)
    ';'       [reduce using rule 10 (varDeclId)]
    ':'       reduce using rule 9 (varDeclId)
    ':'       [reduce using rule 10 (varDeclId)]
    '}'       reduce using rule 9 (varDeclId)
    '}'       [reduce using rule 10 (varDeclId)]
    $default  reduce using rule 9 (varDeclId)


State 37

    1 program: typeSpec varDeclInit . ';' '\n'

    ';'  shift, and go to state 60


State 38

    7 varDeclInit: varDeclId .
    8            | varDeclId . ':' simpleExp

    ':'  shift, and go to state 61

    $default  reduce using rule 7 (varDeclInit)


State 39

   31 boolExp: boolExp AND . unaryRelExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    unaryRelExp  go to state 62
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 40

   30 boolExp: boolExp OR . boolExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    boolExp      go to state 63
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 26


State 41

    4 program: boolExp '\n' .

    $default  reduce using rule 4 (program)


State 42

   41 relOp: EQ .

    $default  reduce using rule 41 (relOp)


State 43

   42 relOp: NEQ .

    $default  reduce using rule 42 (relOp)


State 44

   38 relOp: GREQ .

    $default  reduce using rule 38 (relOp)


State 45

   37 relOp: GR .

    $default  reduce using rule 37 (relOp)


State 46

   39 relOp: SM .

    $default  reduce using rule 39 (relOp)


State 47

   40 relOp: SMEQ .

    $default  reduce using rule 40 (relOp)


State 48

   46 sumOp: '-' .

    $default  reduce using rule 46 (sumOp)


State 49

   45 sumOp: '+' .

    $default  reduce using rule 45 (sumOp)


State 50

    5 program: sumExp '\n' .

    $default  reduce using rule 5 (program)


State 51

   34 unaryRelExp: sumExp relOp . sumExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    sumExp    go to state 64
    mulExp    go to state 25
    unaryExp  go to state 26


State 52

   43 sumExp: sumExp sumOp . mulExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    mulExp    go to state 65
    unaryExp  go to state 26


State 53

   49 mulOp: '*' .

    $default  reduce using rule 49 (mulOp)


State 54

   50 mulOp: '/' .

    $default  reduce using rule 50 (mulOp)


State 55

    6 program: mulExp '\n' .

    $default  reduce using rule 6 (program)


State 56

   47 mulExp: mulExp mulOp . unaryExp

    NUM  shift, and go to state 1
    '-'  shift, and go to state 11

    unaryExp  go to state 66


State 57

   15 stmt: IF '(' simpleExp . ')' compoundStmt
   16     | IF '(' simpleExp . ')' compoundStmt ELSE compoundStmt

    ')'  shift, and go to state 67


State 58

   17 stmt: WHILE simpleExp DO . compoundStmt

    '{'  shift, and go to state 68

    compoundStmt  go to state 69


State 59

   20 stmt: RETURN exp ';' .

    $default  reduce using rule 20 (stmt)


State 60

    1 program: typeSpec varDeclInit ';' . '\n'

    '\n'  shift, and go to state 70


State 61

    8 varDeclInit: varDeclId ':' . simpleExp

    NUM    shift, and go to state 1
    NOT    shift, and go to state 4
    TRUE   shift, and go to state 7
    FALSE  shift, and go to state 8
    '-'    shift, and go to state 11

    NUM       [reduce using rule 27 (simpleExp)]
    NOT       [reduce using rule 27 (simpleExp)]
    TRUE      [reduce using rule 27 (simpleExp)]
    FALSE     [reduce using rule 27 (simpleExp)]
    '-'       [reduce using rule 27 (simpleExp)]
    $default  reduce using rule 27 (simpleExp)

    simpleExp    go to state 71
    boolExp      go to state 29
    unaryRelExp  go to state 18
    sumExp       go to state 24
    mulExp       go to state 25
    unaryExp     go to state 21


State 62

   31 boolExp: boolExp AND unaryRelExp .

    $default  reduce using rule 31 (boolExp)


State 63

   30 boolExp: boolExp . OR boolExp
   30        | boolExp OR boolExp .
   31        | boolExp . AND unaryRelExp

    $default  reduce using rule 30 (boolExp)


State 64

   34 unaryRelExp: sumExp relOp sumExp .
   43 sumExp: sumExp . sumOp mulExp

    '-'  shift, and go to state 48
    '+'  shift, and go to state 49

    '-'       [reduce using rule 34 (unaryRelExp)]
    $default  reduce using rule 34 (unaryRelExp)

    sumOp  go to state 52


State 65

   43 sumExp: sumExp sumOp mulExp .
   47 mulExp: mulExp . mulOp unaryExp

    '*'  shift, and go to state 53
    '/'  shift, and go to state 54

    $default  reduce using rule 43 (sumExp)

    mulOp  go to state 56


State 66

   47 mulExp: mulExp mulOp unaryExp .

    $default  reduce using rule 47 (mulExp)


State 67

   15 stmt: IF '(' simpleExp ')' . compoundStmt
   16     | IF '(' simpleExp ')' . compoundStmt ELSE compoundStmt

    '{'  shift, and go to state 68

    compoundStmt  go to state 72


State 68

   21 compoundStmt: '{' . localDecls stmt '}'

    BOOL  shift, and go to state 2
    INT   shift, and go to state 10

    typeSpec       go to state 73
    localDecls     go to state 74
    scopedVarDecl  go to state 75


State 69

   17 stmt: WHILE simpleExp DO compoundStmt .

    $default  reduce using rule 17 (stmt)


State 70

    1 program: typeSpec varDeclInit ';' '\n' .

    $default  reduce using rule 1 (program)


State 71

    8 varDeclInit: varDeclId ':' simpleExp .

    $default  reduce using rule 8 (varDeclInit)


State 72

   15 stmt: IF '(' simpleExp ')' compoundStmt .
   16     | IF '(' simpleExp ')' compoundStmt . ELSE compoundStmt

    ELSE  shift, and go to state 76

    $default  reduce using rule 15 (stmt)


State 73

   24 scopedVarDecl: typeSpec . varDeclInit

    ID  shift, and go to state 36

    varDeclInit  go to state 77
    varDeclId    go to state 38


State 74

   21 compoundStmt: '{' localDecls . stmt '}'
   22 localDecls: localDecls . scopedVarDecl

    NUM     shift, and go to state 1
    BOOL    shift, and go to state 2
    BREAK   shift, and go to state 3
    NOT     shift, and go to state 4
    IF      shift, and go to state 5
    WHILE   shift, and go to state 6
    TRUE    shift, and go to state 7
    FALSE   shift, and go to state 8
    RETURN  shift, and go to state 9
    INT     shift, and go to state 10
    '-'     shift, and go to state 11

    NUM       [reduce using rule 14 (stmt)]
    NUM       [reduce using rule 27 (simpleExp)]
    BOOL      [reduce using rule 14 (stmt)]
    BOOL      [reduce using rule 27 (simpleExp)]
    BREAK     [reduce using rule 14 (stmt)]
    BREAK     [reduce using rule 27 (simpleExp)]
    NOT       [reduce using rule 14 (stmt)]
    NOT       [reduce using rule 27 (simpleExp)]
    IF        [reduce using rule 14 (stmt)]
    IF        [reduce using rule 27 (simpleExp)]
    WHILE     [reduce using rule 14 (stmt)]
    WHILE     [reduce using rule 27 (simpleExp)]
    TRUE      [reduce using rule 14 (stmt)]
    TRUE      [reduce using rule 27 (simpleExp)]
    FALSE     [reduce using rule 14 (stmt)]
    FALSE     [reduce using rule 27 (simpleExp)]
    RETURN    [reduce using rule 14 (stmt)]
    RETURN    [reduce using rule 27 (simpleExp)]
    INT       [reduce using rule 14 (stmt)]
    INT       [reduce using rule 27 (simpleExp)]
    '-'       [reduce using rule 14 (stmt)]
    '-'       [reduce using rule 27 (simpleExp)]
    '}'       reduce using rule 14 (stmt)
    '}'       [reduce using rule 27 (simpleExp)]
    $default  reduce using rule 14 (stmt)

    program        go to state 31
    typeSpec       go to state 78
    stmt           go to state 79
    scopedVarDecl  go to state 80
    exp            go to state 15
    simpleExp      go to state 16
    boolExp        go to state 17
    unaryRelExp    go to state 18
    sumExp         go to state 19
    mulExp         go to state 20
    unaryExp       go to state 21


State 75

   23 localDecls: scopedVarDecl .

    $default  reduce using rule 23 (localDecls)


State 76

   16 stmt: IF '(' simpleExp ')' compoundStmt ELSE . compoundStmt

    '{'  shift, and go to state 68

    compoundStmt  go to state 81


State 77

   24 scopedVarDecl: typeSpec varDeclInit .

    $default  reduce using rule 24 (scopedVarDecl)


State 78

    1 program: typeSpec . varDeclInit ';' '\n'
   24 scopedVarDecl: typeSpec . varDeclInit

    ID  shift, and go to state 36

    varDeclInit  go to state 82
    varDeclId    go to state 38


State 79

    2 program: stmt .
   21 compoundStmt: '{' localDecls stmt . '}'

    '}'  shift, and go to state 83

    '}'       [reduce using rule 2 (program)]
    $default  reduce using rule 2 (program)


State 80

   22 localDecls: localDecls scopedVarDecl .

    $default  reduce using rule 22 (localDecls)


State 81

   16 stmt: IF '(' simpleExp ')' compoundStmt ELSE compoundStmt .

    $default  reduce using rule 16 (stmt)


State 82

    1 program: typeSpec varDeclInit . ';' '\n'
   24 scopedVarDecl: typeSpec varDeclInit .

    ';'  shift, and go to state 60

    $default  reduce using rule 24 (scopedVarDecl)


State 83

   21 compoundStmt: '{' localDecls stmt '}' .

    $default  reduce using rule 21 (compoundStmt)
